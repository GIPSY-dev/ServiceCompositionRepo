package tests;

import static org.junit.Assert.assertEquals;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import org.junit.Test;
import compositionprocesses.BackwardSearch;
import compositionprocesses.ForwardExpansion;
import compositionprocesses.PlanConstruction;
import entities.CompositionPlan;
import entities.CompositionRequest;
import entities.SearchGraph;
import entities.SearchNode;
import service.Service;
import service.ServiceParser;
import service.ServiceXMLParser;

/**
 * Class for testing construction of composition plans from the plan sets generated by the backward search algorithm.
 * We populate only the inputs and outputs of test composition requests because QoS
 * and constraints play no role in (and have no effect on) the plan construction process. 
 * @author Jyotsana Gupta
 */
public class PlanConstructionTests 
{
	/**
	 * Tests the following requirements:
	 * 1. Correct execution of plan construction, validation, pruning and addition to the plan list.
	 * 2. Checking that search nodes with no valid successors should produce at least 1 requested output.
	 * 3. Removal of invalid search nodes from composition plans.
	 * 4. Addition of a valid plan to the plan list only if it is a unique plan. Discarding of duplicate plans.
	 * 5. Repetitive validation of a plan until no more search nodes could be removed from it.
	 * 6. Correct plan layer count calculation.
	 */
	@Test
	public void planConstruction()
	{
		List<String> compReqInputs = new ArrayList<String>(Arrays.asList("input11", "input12", "input21", "input22", "input31", "input42", "input61", "output22"));
		List<String> compReqOutputs = new ArrayList<String>(Arrays.asList("output11", "input32"));
		String repoXMLFileName = "testinput/Test_Services_Set_1.xml";
		List<String> actualPlanDetails = new ArrayList<String>();
		
		int actualPlanCount = getActualPlanResults(compReqInputs, compReqOutputs, repoXMLFileName, actualPlanDetails);
		
		int expectedPlanCount = 2;
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: sname1, sname8");
		expectedPlanDetails.add("Layer 0: sname8\nLayer 1: sname3\nLayer 2: sname7");
		
		assertEquals(actualPlanCount, expectedPlanCount);
		assertEquals(actualPlanDetails, expectedPlanDetails);
	}
	
	/**
	 * Tests that search nodes whose inputs are not completely available should be removed from the plan.
	 */
	@Test
	public void serviceInputValidation()
	{
		List<String> compReqInputs = new ArrayList<String>(Arrays.asList("input11", "input21"));
		List<String> compReqOutputs = new ArrayList<String>(Arrays.asList("output131"));
		String repoXMLFileName = "testinput/Test_Services_Set_2.xml";
		List<String> actualPlanDetails = new ArrayList<String>();
		
		int actualPlanCount = getActualPlanResults(compReqInputs, compReqOutputs, repoXMLFileName, actualPlanDetails);
		
		int expectedPlanCount = 1;
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: sname1, sname2\nLayer 1: sname10, sname9\nLayer 2: sname11, sname12\nLayer 3: sname13");
		
		assertEquals(actualPlanCount, expectedPlanCount);
		assertEquals(actualPlanDetails, expectedPlanDetails);
	}
	
	/**
	 * Tests the following requirements:
	 * 1. A pruned plan that does not produce all the requested outputs should be discarded.
	 * 2. Validation failure of both inputs and outputs of search nodes in a plan and their removal from it.
	 */
	@Test
	public void compReqOutputVerification()
	{
		List<String> compReqInputs = new ArrayList<String>(Arrays.asList("input11", "input12", "input21", "input22"));
		List<String> compReqOutputs = new ArrayList<String>(Arrays.asList("output71", "output81"));
		String repoXMLFileName = "testinput/Test_Services_Set_2.xml";
		List<String> actualPlanDetails = new ArrayList<String>();
		
		int actualPlanCount = getActualPlanResults(compReqInputs, compReqOutputs, repoXMLFileName, actualPlanDetails);
		
		int expectedPlanCount = 3;
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: sname1\nLayer 1: sname3, sname4\nLayer 2: sname7, sname8");
		expectedPlanDetails.add("Layer 0: sname1, sname2\nLayer 1: sname3, sname4\nLayer 2: sname7, sname8");
		expectedPlanDetails.add("Layer 0: sname2\nLayer 1: sname3, sname4\nLayer 2: sname7, sname8");
		
		assertEquals(actualPlanCount, expectedPlanCount);
		assertEquals(actualPlanDetails, expectedPlanDetails);
	}
	
	/**
	 * Tests the following scenarios:
	 * 1. Plans with parallel branches producing all requested outputs.
	 * 2. Plans with an empty layer. In this test case, layer 0 is empty for 2 plans.
	 */
	@Test
	public void specialCases()
	{
		List<String> compReqInputs = new ArrayList<String>(Arrays.asList("input11", "input12", "input21", "input22"));
		List<String> compReqOutputs = new ArrayList<String>(Arrays.asList("output51", "output52"));
		String repoXMLFileName = "testinput/Test_Services_Set_2.xml";
		List<String> actualPlanDetails = new ArrayList<String>();
		
		int actualPlanCount = getActualPlanResults(compReqInputs, compReqOutputs, repoXMLFileName, actualPlanDetails);
		
		int expectedPlanCount = 7;
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: \nLayer 1: sname3\nLayer 2: sname5");
		expectedPlanDetails.add("Layer 0: \nLayer 1: sname4\nLayer 2: sname6");
		expectedPlanDetails.add("Layer 0: sname1\nLayer 1: sname3\nLayer 2: sname5");
		expectedPlanDetails.add("Layer 0: sname1\nLayer 1: sname3, sname4\nLayer 2: sname5, sname6");
		expectedPlanDetails.add("Layer 0: sname1, sname2\nLayer 1: sname3, sname4\nLayer 2: sname5, sname6");
		expectedPlanDetails.add("Layer 0: sname2\nLayer 1: sname3, sname4\nLayer 2: sname5, sname6");
		expectedPlanDetails.add("Layer 0: sname2\nLayer 1: sname4\nLayer 2: sname6");
		
		assertEquals(actualPlanCount, expectedPlanCount);
		assertEquals(actualPlanDetails, expectedPlanDetails);
	}
	
	/**
	 * Method for constructing plans from the plan sets generated by the backward search algorithm for a given composition request.
	 * @param 	compReqInputs		Composition request inputs
	 * @param 	compReqOutputs		Composition request outputs
	 * @param 	repoXMLFileName		Complete name of the XML file containing the service repository
	 * @param 	actualPlanDetails	List of strings containing layer-wise service names from the generated plans
	 * @return	Number of valid plans generated for the given composition request
	 */
	private int getActualPlanResults(List<String> compReqInputs, List<String> compReqOutputs, String repoXMLFileName, List<String> actualPlanDetails)
	{
		//Creating a composition request based on the given inputs and outputs
		CompositionRequest compositionReq = new CompositionRequest();
		compositionReq.setInputs(compReqInputs);
		compositionReq.setOutputs(compReqOutputs);
		
		//Reading the service repository
		ServiceParser serviceParser = new ServiceXMLParser();
		ArrayList<Service> serviceRepo = serviceParser.parse(repoXMLFileName);
		
		//Using forward expansion to generate a search graph
		SearchGraph resultingGraph = ForwardExpansion.forwardExpansion(compositionReq, serviceRepo);
		
		//Using backward search for constructing plan sets
		List<Set<SearchNode>> planSets = BackwardSearch.backwardSearch(compositionReq, resultingGraph);
		
		//Constructing pruned and validated plans from the plan sets
		List<CompositionPlan> plans = PlanConstruction.constructPlans(compositionReq, planSets);
		for (CompositionPlan plan : plans)
		{
			actualPlanDetails.add(plan.toString());
		}
		Collections.sort(actualPlanDetails);
		
		return plans.size();
	}
}