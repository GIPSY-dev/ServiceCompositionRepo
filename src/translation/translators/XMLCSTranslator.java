package translation.translators;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import service.composite.layeredcompsvc.LayeredCompositeService;
import servicecomposition.entities.ConstraintAwarePlan;
import servicecomposition.entities.ServiceNode;
import constraint.Constraint;
import constraint.ConstraintXMLWriter;
import service.ConstrainedService;
import service.Service;
import translation.readers.csconfigreaders.CSConfiguration;
import utilities.LogUtil;

/**
 * Concrete translator for generating an XML representation of a layered composite service.
 * @author Jyotsana Gupta
 */
public class XMLCSTranslator implements CompositeServiceTranslator
{
	/**
	 * Method for translating a given layered composite service into an XML representation.
	 * @param 	compSvcConfig	Composite service configuration containing information required for the translation
	 * @param 	logger			Logging utility object for logging error or status messages to a text file
	 * @return	Complete name and path of the XML file generated by this translator
	 */
	public String generateFormalLangCode(CSConfiguration compSvcConfig, LogUtil logger)
	{
		String csXMLFileName = compServiceToXML(compSvcConfig, logger);
		return csXMLFileName;
	}
	
	/**
	 * Method for sequentially triggering the phases involved in generation of an XML representation of a composite service.
	 * @param 	compSvcConfig	Composite service configuration received from the user
	 * @return	Complete name and path of the XML file generated
	 */
	private String compServiceToXML(CSConfiguration compSvcConfig, LogUtil logger)
	{
		//Fetching composite service information from the given configuration
		Service compService = compSvcConfig.getCompositeService();
		String compServiceName = compService.getName();
		String destFolderName = compSvcConfig.getDestinationFolder();
		
		//Creating the XML document
		Document doc = createXMLDocument(logger);
		
		//Creating the XML elements to be written in the document
		createXMLElements(doc, compService);
					
		//Writing the elements to the XML file
		String csXMLFileName = xmlDocToXMLFile(doc, destFolderName, compServiceName, logger);
		
		return csXMLFileName;
	}
	
	/**
	 * Method for creating an XML document which could be written into.
	 * @param 	logger		Logging utility object for logging error or status messages to a text file
	 * @return	XML document created for writing
	 */
	private Document createXMLDocument(LogUtil logger)
	{
		DocumentBuilderFactory docBldrFactory = DocumentBuilderFactory.newInstance();		
		DocumentBuilder docBldr = null;
		try
		{
			docBldr = docBldrFactory.newDocumentBuilder();
		}
		catch(ParserConfigurationException pce)
		{
			logger.log("Exception occurred while creating XML document builder: " + pce.getMessage());
			return null;
		}		
		Document doc = docBldr.newDocument();
		
		return doc;
	}
	
	/**
	 * Method for creating the XML elements of a layered composite service and adding them to the XML document.
	 * @param 	doc				XML document to which the elements need to be added
	 * @param 	compService		Layered composite service that needs to be written
	 */
	private void createXMLElements(Document doc, Service compService)
	{
		//Fetching composite service information
		String compServiceName = compService.getName();
		List<String> compServiceInputs = compService.getInput();
		List<String> compServiceOutputs = compService.getOutput();
		List<String> compServiceEffects = ((ConstrainedService)compService.getInnerService()).getEffects();
		List<Constraint> compServiceConstraints = ((ConstrainedService)compService.getInnerService()).getConstraints();
		ConstraintAwarePlan cnstrAwrPlan = ((LayeredCompositeService)compService).getCompositionPlan();
		List<Service> atomicServices = new ArrayList<Service>();
		for (List<ServiceNode> serviceLayer : cnstrAwrPlan.getServiceLayers())
		{
			for (ServiceNode serviceNode : serviceLayer)
			{
				atomicServices.add(serviceNode.getService());
			}
		}
		
		//Creating the root element
		Element rootElem = doc.createElement("compositeservices");
		doc.appendChild(rootElem);
		
		//Creating the composite service element
		Element csElem = doc.createElement("compositeservice");
		rootElem.appendChild(csElem);
		
		//Creating the composite service name, input, output and effect elements
		createAttributedElement(doc, "csname", csElem, "value", compServiceName);
		createListElements(doc, "csinputs", csElem, compServiceInputs, "instance", "name");
		createListElements(doc, "csoutputs", csElem, compServiceOutputs, "instance", "name");
		createListElements(doc, "cseffects", csElem, compServiceEffects, "instance", "name");
		
		//Creating the composite service constraint elements
		Element csConstraintsElem = doc.createElement("csconstraints");
		csElem.appendChild(csConstraintsElem);
		ConstraintXMLWriter cnstrWriter = new ConstraintXMLWriter();
		for (Constraint constraint : compServiceConstraints)
		{			
			cnstrWriter.createConstraintElement(doc, csConstraintsElem, constraint);
		}
		
		//Creating the composition plan element
		createCSPlanElement(doc, csElem, cnstrAwrPlan);
		
		//Creating the component atomic service elements
		Element csAtmSvcsElem = doc.createElement("csatomicservices");
		csElem.appendChild(csAtmSvcsElem);
		for (Service service : atomicServices)
		{
			createServiceElement(doc, csAtmSvcsElem, service);
		}
	}
	
	/**
	 * Method for transforming an XML document into an XML file. 
	 * @param 	doc					XML document to be transformed
	 * @param 	destFolderName		Complete name and path of the folder in which the XML file needs to be stored
	 * @param 	compServiceName		Name of the composite service to be stored in the XML file. It is required for naming the file.
	 * @param 	logger				Logging utility object for logging error or status messages to a text file
	 * @return	Complete name and path of the XML file generated
	 */
	private String xmlDocToXMLFile(Document doc, String destFolderName, String compServiceName, LogUtil logger)
	{
		TransformerFactory transformerFactory = TransformerFactory.newInstance();
		DOMSource domSource = new DOMSource(doc);
		String csXMLFileName = destFolderName + "CSXML_" + compServiceName + ".xml";
		StreamResult domDestination = new StreamResult(new File(csXMLFileName));
		try
		{
			Transformer transformer = transformerFactory.newTransformer();			
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");
			transformer.transform(domSource, domDestination);
		}
		catch(TransformerException te)
		{
			logger.log("Exception occurred while writing composite service to XML file: " + te.getMessage());
			return null;
		}
		
		return csXMLFileName;
	}
	
	/**
	 * Method for creating an XML element with a list of simple attributed sub-elements.
	 * @param 	doc				Container document for the elements
	 * @param 	elemName		Name of the outermost element to be created
	 * @param 	parentElem		Parent element of the outermost element to be created
	 * @param 	itemList		List of attribute values for the sub-elements to be created
	 * @param 	itemName		Common name of each of the sub-elements
	 * @param 	itemAttrName	Common name of the attribute of each of the sub-elements
	 */
	private void createListElements(Document doc, String elemName, Element parentElem, List<String> itemList, String itemName, String itemAttrName)
	{
		Element listElem = doc.createElement(elemName);
		parentElem.appendChild(listElem);
		for (String item : itemList)
		{
			createAttributedElement(doc, itemName, listElem, itemAttrName, item);
		}
	}
	
	/**
	 * Method for creating the composition plan element of a layered composite service.
	 * @param 	doc				Container document for the element
	 * @param 	parentElem		Parent element of the composition plan element
	 * @param 	cnstrAwrPlan	Constraint-aware composition plan whose element representation needs to be created
	 */
	private void createCSPlanElement(Document doc, Element parentElem, ConstraintAwarePlan cnstrAwrPlan)
	{
		//Creating the composition plan outermost element
		Element csPlanElem = doc.createElement("csplan");
		parentElem.appendChild(csPlanElem);
		
		//Creating elements for each service layer in the plan
		for (int i = 0; i < cnstrAwrPlan.getServiceLayerCount(); i++)
		{
			Element svcLayerElem = createAttributedElement(doc, "servicelayer", csPlanElem, "index", i+"");
			
			//Creating elements for each service node in the current layer
			for (ServiceNode serviceNode : cnstrAwrPlan.getServiceLayers().get(i))
			{
				//Fetching service information
				Service service = serviceNode.getService();
				String svcName = service.getName();
				List<Constraint> svcConstraints = ((ConstrainedService)service).getConstraints();
				
				//Creating service node element
				Element svcNodeElem = doc.createElement("servicenode");
				svcLayerElem.appendChild(svcNodeElem);
				
				//Creating element for the service node's service component
				createAttributedElement(doc, "service", svcNodeElem, "name", svcName);
				
				//Creating elements for the service node's constraints component
				Element svcConstraintsElem = doc.createElement("constraints");
				svcNodeElem.appendChild(svcConstraintsElem);
				ConstraintXMLWriter cnstrWriter = new ConstraintXMLWriter();
				for (Constraint constraint : svcConstraints)
				{			
					cnstrWriter.createConstraintElement(doc, svcConstraintsElem, constraint);
				}
				
				//Creating elements for the service node's predecessors component
				List<ServiceNode> predecessors = serviceNode.getPredecessors();
				List<String[]> predDetails = new ArrayList<String[]>();
				for (ServiceNode predecessor : predecessors)
				{
					String[] predRecord = {predecessor.getLayerIndex()+"", predecessor.getService().getName()};
					predDetails.add(predRecord);
				}
				createPredElements(doc, svcNodeElem, predDetails);
			}
		}
	}
	
	/**
	 * Method for creating elements for a service node's predecessors component.
	 * @param 	doc				Container document for the elements
	 * @param 	parentElem		Parent element of the predecessors element
	 * @param 	predDetails		List of predecessor service names and layer indices
	 */
	private void createPredElements(Document doc, Element parentElem, List<String[]> predDetails)
	{
		Element predsElem = doc.createElement("predecessors");
		parentElem.appendChild(predsElem);
		for (String[] predRecord : predDetails)
		{
			Element predInstElem = createAttributedElement(doc, "instance", predsElem, "name", predRecord[1]);
			Attr layerIndexAttr = doc.createAttribute("layerindex");
			layerIndexAttr.setValue(predRecord[0]);
			predInstElem.setAttributeNode(layerIndexAttr);
		}
	}
	
	/**
	 * Method for creating a simple element with an attribute.
	 * @param 	doc				Container document for the element
	 * @param 	elemName		Name of the element to be created
	 * @param 	parentElem		Parent element of the element to be created
	 * @param 	attrName		Name of the attribute of the element to be created
	 * @param 	attrValue		Value of the attribute of the element to be created
	 * @return	Attributed element created
	 */
	private Element createAttributedElement(Document doc, String elemName, Element parentElem, String attrName, String attrValue)
	{
		Element element = doc.createElement(elemName);
		parentElem.appendChild(element);
		Attr attribute = doc.createAttribute(attrName);
		attribute.setValue(attrValue);
		element.setAttributeNode(attribute);
		
		return element;
	}
	
	/**
	 * Method for creating an element for a constrained service.
	 * @param 	doc				Container document for the element
	 * @param 	parentElem		Parent element for the service element to be created
	 * @param 	service			Service whose element representation needs to be created
	 */
	private void createServiceElement(Document doc, Element parentElem, Service service)
	{
		//Creating service element and its name attribute
		Element serviceElem = doc.createElement("service");
		parentElem.appendChild(serviceElem);
		Attr serviceAttr = doc.createAttribute("name");
		serviceAttr.setValue(service.getName());
		serviceElem.setAttributeNode(serviceAttr);
		
		//Creating service input elements and their name attributes
		Element inputElem = doc.createElement("inputs");
		serviceElem.appendChild(inputElem);
		for (String input : service.getInput())
		{
			Element inpInstanceElem = doc.createElement("instance");
			inputElem.appendChild(inpInstanceElem);				
			Attr inpInstanceAttr = doc.createAttribute("name");
			inpInstanceAttr.setValue(input);
			inpInstanceElem.setAttributeNode(inpInstanceAttr);
		}
		
		//Creating service output elements and their name attributes
		Element outputElem = doc.createElement("outputs");
		serviceElem.appendChild(outputElem);
		for (String output : service.getOutput())
		{
			Element outpInstanceElem = doc.createElement("instance");
			outputElem.appendChild(outpInstanceElem);				
			Attr outpInstanceAttr = doc.createAttribute("name");
			outpInstanceAttr.setValue(output);
			outpInstanceElem.setAttributeNode(outpInstanceAttr);
		}
		
		//Creating service constraint elements and their sub-elements and attributes
		Element constraintElem = doc.createElement("constraints");
		serviceElem.appendChild(constraintElem);
		List<Constraint> constraints = ((ConstrainedService)service).getConstraints();
		if (constraints != null)
		{
			ConstraintXMLWriter constXMLWriter = new ConstraintXMLWriter();
			for (Constraint constraint : constraints)
			{
				constXMLWriter.createConstraintElement(doc, constraintElem, constraint);
			}
		}
		
		//Creating service effect elements and their name attributes
		Element effectElem = doc.createElement("effects");
		serviceElem.appendChild(effectElem);
		for (String effect : ((ConstrainedService)service).getEffects())
		{
			Element effInstanceElem = doc.createElement("instance");
			effectElem.appendChild(effInstanceElem);
			Attr effInstanceAttr = doc.createAttribute("name");
			effInstanceAttr.setValue(effect);
			effInstanceElem.setAttributeNode(effInstanceAttr);
		}
	}
}