package translation.tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

import java.io.File;
//import java.util.ArrayList;
//import java.util.Collections;
//import java.util.List;

import org.junit.Test;

//import servicecomposition.compositionprocesses.ServiceComposition;
//import servicecomposition.entities.ConstraintAwarePlan;
//import servicecomposition.readers.FileReqConfigReader;
//import servicecomposition.readers.RequestConfiguration;
//import servicecomposition.readers.XMLFileReqConfigReader;
import translation.readers.csconfigreaders.CSConfiguration;
import translation.readers.csconfigreaders.FileCSConfigReader;
import translation.readers.csconfigreaders.XMLFileCSConfigReader;
import translation.translators.CompositeServiceTranslator;
import translation.translators.LucidCSTranslator;
import utilities.LogUtil;
import utilities.ReadWriteUtil;

/**
 * Class for testing correct generation of the Java segment of a composite service's Objective Lucid translation.
 * @author Jyotsana Gupta
 */
public class OLTransJavaSegGenTests 
{
	/**
	 * Tests correct generation of the following definitions for a sequential composition plan:
	 * 1. Output accumulator Java class for a composite service with just 1 output.
	 * 2. Java class for a component service (W1) with just 1 input - from the user.
	 * 3. Java class for a component service (W2) with just 1 input - from another component service.
	 * 4. Java class for a component service (W2) with just 1 output - to output accumulator.
	 * 5. Java class for a component service (W1) with just 1 output - to another component service.
	 * 6. Java constructor initialization statements for char type output (W1).
	 * 7. Java process function assignment statements for char type output (W1).
	 * 8. Java data type for char type composite service output (W2).
	 * 9. Java data type for char type component service input (W1).
	 * 10. Java data type for char type component service output (W1).
	 * 11. Java free function for a component service (W1) with just 1 input - from the user.
	 * 12. Java free function for a component service (W2) with just 1 input - from another component service.
	 * -------------------------------------------------------------------------------------------------------
	 * 13. Lucid main expression, context and global dimensions for a composite service with just 1 input.
	 * 14. Lucid main expression's context for char type dimension.
	 * 15. Output accumulator Lucid definition for a composite service with just 1 output.
	 * 16. Lucid definition for a component service (W1) with just 1 input - from the user.
	 * 17. Lucid definition for a component service (W2) with just 1 input - from another component service.
	 */
	@Test
	public void seqCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/oltransjavaseggentests/seqcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);		
				
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/oltransjavaseggentests/seqcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/oltransjavaseggentests/seqcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a join composition plan:
	 * 1. Output accumulator Java class for a composite service with multiple outputs generated by a single component service.
	 * 2. Java class for a component service (W3) with multiple outputs - to output accumulator.
	 * 3. Constructor initialization statements for String, int and boolean type outputs (W3).
	 * 4. Process function assignment statements for String, int and boolean type outputs (W3).
	 * 5. Java data type for String, int and boolean type composite service outputs (W3).
	 * 6. Java data type for float and boolean type component service inputs (W2 and W3).
	 * 7. Java data type for String, int and boolean type component service outputs (W3).
	 * -----------------------------------------------------------------------------------------------------------------------------
	 * 8. Lucid main expression's context for float and int type dimensions.
	 * 9. Output accumulator Lucid definition for a composite service with multiple outputs generated by a single component service.
	 */
	@Test
	public void joinCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/oltransjavaseggentests/joincompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);		
				
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/oltransjavaseggentests/joincompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/oltransjavaseggentests/joincompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a split composition plan:
	 * 1. Output accumulator Java class for a composite service with multiple outputs generated
	 * by multiple component services belonging to the last layer of the composition plan.
	 * 2. Java class for a component service (W1) with multiple inputs - from the user.
	 * 3. Java class for a component service (W2) with multiple inputs - from another component service.
	 * 4. Java class for a component service (W1) with an output parameter 
	 * that serves as an input parameter for multiple component services.
	 * 5. Java class for a component service (W1) with multiple outputs - to another component service.
	 * 6. Java class for a component service (W1) with multiple outputs - to multiple component services.
	 * 7. Constructor initialization statements for (multiple) float/double type outputs (W2).
	 * 8. Process function assignment statements for (multiple) float/double type outputs (W2).
	 * 9. Java data type for float type composite service output (W2).
	 * 10. Java data type for String and int type component service inputs (W2).
	 * 11. Java data type for float type component service output (W2).
	 * 12. Java free function for a component service (W1) with multiple inputs - from the user.
	 * 13. Java free function for a component service (W2) with multiple inputs - from another component service.
	 * -------------------------------------------------------------------------------------------------------------------------
	 * 14. Lucid main expression, context and global dimensions for a composite service with multiple inputs of different types.
	 * 15. Lucid main expression's context for String and boolean type dimensions.
	 * 16. Output accumulator Lucid definition for a composite service with multiple outputs generated
	 * by multiple component services belonging to the last layer of the composition plan.
	 * 17. Lucid definition for a component service (W1) with multiple inputs - from the user.
	 * 18. Lucid definition for a component service (W2) with multiple inputs - from another component service.
	 */
	@Test
	public void splitCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/oltransjavaseggentests/splitcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);		
				
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/oltransjavaseggentests/splitcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/oltransjavaseggentests/splitcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a parallel composition plan:
	 * 1. Java class for a component service (W3) with multiple inputs - from multiple component services in different layers.
	 * 2. Java class for a component service (W6) with multiple inputs - from the user and multiple component services in different layers.
	 * ------------------------------------------------------------------------------------------------------------------------------------------
	 * 3. Lucid main expression, context and global dimensions for a composite service with multiple inputs of the same type.
	 * 4. Lucid definition for a component service (W3) with multiple inputs - from multiple component services in different layers.
	 * 5. Lucid definition for a component service (W6) with multiple inputs - from the user and multiple component services in different layers.
	 */
	@Test
	public void parallelCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/oltransjavaseggentests/parallelcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);
				
		/*
		 * The commented part below was used during the first run of this test case 
		 * to ensure that the composite service used for translation can be created.
		 */
		/*
		//Creating composite service
		FileReqConfigReader configReader = new XMLFileReqConfigReader();
		configReader.setConfigFileName("testinput/translationtests/oltransjavaseggentests/parallelcompsvc/Request_Configuration.xml");
		RequestConfiguration reqConfig = configReader.readReqConfig();
		
		List<String> actualPlanDetails = new ArrayList<String>();
		List<ConstraintAwarePlan> cnstrAwrPlans = ServiceComposition.driveServiceComposition(reqConfig, logger);
		for (ConstraintAwarePlan cnstrAwrPlan : cnstrAwrPlans)
		{
			actualPlanDetails.add(cnstrAwrPlan.toString());
		}
		Collections.sort(actualPlanDetails);
		
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: {} [] W1 {W2, W3}, {} [] W4 {W5, W6}" 
								+ "\nLayer 1: {W1} [] W2 {W3}, {W4} [] W5 {W6}" 
								+ "\nLayer 2: {W1, W2} [] W3 {}, {W4, W5} [] W6 {}");
				
		File actualLogFile = new File(actualLogFileName);
		boolean compLogGenerated = (!(actualLogFile.length() == 0));
		
		assertFalse(compLogGenerated);
		assertEquals(actualPlanDetails, expectedPlanDetails);
		*/
		
		//Translating created composite service into Lucid
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/oltransjavaseggentests/parallelcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/oltransjavaseggentests/parallelcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean transLogGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(transLogGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a combinational composition plan:
	 * 1. Output accumulator Java class for a composite service with multiple outputs generated
	 * by multiple component services belonging to different layers of the composition plan.
	 * 2. Java class for a component service (W5) with 1 output - to accumulator and another component service.
	 * 3. Java class for a component service (W3) with multiple outputs - to accumulator and multiple component services.
	 * ------------------------------------------------------------------------------------------------------------------
	 * 4. Output accumulator Lucid definition for a composite service with multiple outputs generated
	 * by multiple component services belonging to different layers of the composition plan.
	 */
	@Test
	public void combCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/oltransjavaseggentests/combcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);
				
		/*
		 * The commented part below was used during the first run of this test case 
		 * to ensure that the composite service used for translation can be created.
		 */
		/*
		//Creating composite service
		FileReqConfigReader configReader = new XMLFileReqConfigReader();
		configReader.setConfigFileName("testinput/translationtests/oltransjavaseggentests/combcompsvc/Request_Configuration.xml");
		RequestConfiguration reqConfig = configReader.readReqConfig();
		
		List<String> actualPlanDetails = new ArrayList<String>();
		List<ConstraintAwarePlan> cnstrAwrPlans = ServiceComposition.driveServiceComposition(reqConfig, logger);
		for (ConstraintAwarePlan cnstrAwrPlan : cnstrAwrPlans)
		{
			actualPlanDetails.add(cnstrAwrPlan.toString());
		}
		Collections.sort(actualPlanDetails);
		
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: {} [] W1 {W3}, {} [] W2 {W3}" 
								+ "\nLayer 1: {W1, W2} [] W3 {W4, W5}" 
								+ "\nLayer 2: {W3} [] W4 {W6}, {W3} [] W5 {W7}"
								+ "\nLayer 3: {W4} [] W6 {}, {W5} [] W7 {}");
				
		File actualLogFile = new File(actualLogFileName);
		boolean compLogGenerated = (!(actualLogFile.length() == 0));
		
		assertFalse(compLogGenerated);
		assertEquals(actualPlanDetails, expectedPlanDetails);
		*/
		
		//Translating created composite service into Lucid
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/oltransjavaseggentests/combcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/oltransjavaseggentests/combcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean transLogGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(transLogGenerated);
	}
}