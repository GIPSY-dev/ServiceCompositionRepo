package translation.tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

import java.io.File;
//import java.util.ArrayList;
//import java.util.Collections;
//import java.util.List;

import org.junit.Test;

//import servicecomposition.compositionprocesses.ServiceComposition;
//import servicecomposition.entities.ConstraintAwarePlan;
//import servicecomposition.readers.FileReqConfigReader;
//import servicecomposition.readers.RequestConfiguration;
//import servicecomposition.readers.XMLFileReqConfigReader;
import translation.readers.csconfigreaders.CSConfiguration;
import translation.readers.csconfigreaders.FileCSConfigReader;
import translation.readers.csconfigreaders.XMLFileCSConfigReader;
import translation.translators.CompositeServiceTranslator;
import translation.translators.LucidCSTranslator;
import utilities.LogUtil;
import utilities.ReadWriteUtil;

/**
 * Class for testing correct generation of a composite service's Objective Lucid translation for evaluation purposes.
 * @author Jyotsana Gupta
 */
public class LucidTransEvalTests 
{
	/**
	 * Tests correct generation of the following definitions for a sequential composition plan:
	 * 1. Output accumulator Java class for a composite service with just 1 output.
	 * 2. Java class for a component service (W1) with just 1 input - from the user.
	 * 3. Java class for a component service (W2) with just 1 input - from another component service.
	 * 4. Java class for a component service (W2) with just 1 output - to output accumulator.
	 * 5. Java class for a component service (W1) with just 1 output - to another component service.
	 * 6. Java constructor initialization statements for char type output (W1).
	 * 7. Java process function assignment statements for char type output (W1).
	 * 8. Java data type for char type composite service output (W2).
	 * 9. Java data type for char type component service input (W1).
	 * 10. Java data type for char type component service output (W1).
	 * 11. Java free function for a component service (W1) with just 1 input - from the user.
	 * 12. Java free function for a component service (W2) with just 1 input - from another component service.
	 * -------------------------------------------------------------------------------------------------------
	 * 13. Lucid main expression, context and global dimensions for a composite service with just 1 input.
	 * 14. Lucid main expression's context for char type dimension.
	 * 15. Output accumulator Lucid definition for a composite service with just 1 output.
	 * 16. Lucid definition for a component service (W1) with just 1 input - from the user.
	 * 17. Lucid definition for a component service (W2) with just 1 input - from another component service.
	 * -------------------------------------------------------------------------------------------------------
	 * 18. Objective Lucid translation for a sequential organization of component services.
	 * 19. Objective Lucid translation for a composite service with just 1 service in first layer.
	 * 20. Objective Lucid translation for a composite service with just 1 service in last layer.
	 */
	@Test
	public void seqCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/lucidtransevaltests/seqcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);		
				
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/seqcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/lucidtransevaltests/seqcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a join composition plan:
	 * 1. Output accumulator Java class for a composite service with multiple outputs generated by a single component service.
	 * 2. Java class for a component service (W3) with multiple outputs - to output accumulator.
	 * 3. Constructor initialization statements for String, int and boolean type outputs (W3).
	 * 4. Process function assignment statements for String, int and boolean type outputs (W3).
	 * 5. Java data type for String, int and boolean type composite service outputs (W3).
	 * 6. Java data type for float and boolean type component service inputs (W2 and W3).
	 * 7. Java data type for String, int and boolean type component service outputs (W3).
	 * -----------------------------------------------------------------------------------------------------------------------------
	 * 8. Lucid main expression's context for float and int type dimensions.
	 * 9. Output accumulator Lucid definition for a composite service with multiple outputs generated by a single component service.
	 * -----------------------------------------------------------------------------------------------------------------------------
	 * 10. Objective Lucid translation for a joined organization of component services.
	 */
	@Test
	public void joinCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/lucidtransevaltests/joincompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);		
				
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/joincompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/lucidtransevaltests/joincompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a split composition plan:
	 * 1. Output accumulator Java class for a composite service with multiple outputs generated
	 * by multiple component services belonging to the last layer of the composition plan.
	 * 2. Java class for a component service (W1) with multiple inputs - from the user.
	 * 3. Java class for a component service (W2) with multiple inputs - from another component service.
	 * 4. Java class for a component service (W1) with an output parameter that serves 
	 * as an input parameter for multiple component services in the same layer.
	 * 5. Java class for a component service (W1) with multiple outputs - to another component service.
	 * 6. Java class for a component service (W1) with multiple outputs - to multiple component services in the same layer.
	 * 7. Constructor initialization statements for (multiple) float/double type outputs (W2).
	 * 8. Process function assignment statements for (multiple) float/double type outputs (W2).
	 * 9. Java data type for float type composite service output (W2).
	 * 10. Java data type for String and int type component service inputs (W2).
	 * 11. Java data type for float type component service output (W2).
	 * 12. Java free function for a component service (W1) with multiple inputs - from the user.
	 * 13. Java free function for a component service (W2) with multiple inputs - from another component service.
	 * -------------------------------------------------------------------------------------------------------------------------
	 * 14. Lucid main expression, context and global dimensions for a composite service with multiple inputs of different types.
	 * 15. Lucid main expression's context for String and boolean type dimensions.
	 * 16. Output accumulator Lucid definition for a composite service with multiple outputs generated
	 * by multiple component services belonging to the last layer of the composition plan.
	 * 17. Lucid definition for a component service (W1) with multiple inputs - from the user.
	 * 18. Lucid definition for a component service (W2) with multiple inputs - from another component service.
	 * -------------------------------------------------------------------------------------------------------------------------
	 * 19. Objective Lucid translation for a split organization of component services.
	 */
	@Test
	public void splitCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/lucidtransevaltests/splitcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);		
				
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/splitcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/lucidtransevaltests/splitcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a parallel composition plan:
	 * 1. Java class for a component service (W3) with multiple inputs - from multiple component services in different layers.
	 * 2. Java class for a component service (W6) with multiple inputs - from the user and multiple component services in different layers.
	 * 3. Java class for a component service (W4) with an output parameter that serves 
	 * as an input parameter for multiple component services in different layers.
	 * 4. Java class for a component service (W1) with multiple outputs - to multiple component services in different layers.
	 * ------------------------------------------------------------------------------------------------------------------------------------------
	 * 5. Lucid main expression, context and global dimensions for a composite service with multiple inputs of the same type.
	 * 6. Lucid definition for a component service (W3) with multiple inputs - from multiple component services in different layers.
	 * 7. Lucid definition for a component service (W6) with multiple inputs - from the user and multiple component services in different layers.
	 * ------------------------------------------------------------------------------------------------------------------------------------------
	 * 8. Objective Lucid translation for a parallel organization of component services.
	 */
	@Test
	public void parallelCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/lucidtransevaltests/parallelcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);
				
		/*
		 * The commented part below was used during the first run of this test case 
		 * to ensure that the composite service used for translation can be created.
		 */
		/*
		//Creating composite service
		FileReqConfigReader configReader = new XMLFileReqConfigReader();
		configReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/parallelcompsvc/Request_Configuration.xml");
		RequestConfiguration reqConfig = configReader.readReqConfig();
		
		List<String> actualPlanDetails = new ArrayList<String>();
		List<ConstraintAwarePlan> cnstrAwrPlans = ServiceComposition.driveServiceComposition(reqConfig, logger);
		for (ConstraintAwarePlan cnstrAwrPlan : cnstrAwrPlans)
		{
			actualPlanDetails.add(cnstrAwrPlan.toString());
		}
		Collections.sort(actualPlanDetails);
		
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: {} [] W1 {W2, W3}, {} [] W4 {W5, W6}" 
								+ "\nLayer 1: {W1} [] W2 {W3}, {W4} [] W5 {W6}" 
								+ "\nLayer 2: {W1, W2} [] W3 {}, {W4, W5} [] W6 {}");
				
		File actualLogFile = new File(actualLogFileName);
		boolean compLogGenerated = (!(actualLogFile.length() == 0));
		
		assertFalse(compLogGenerated);
		assertEquals(actualPlanDetails, expectedPlanDetails);
		*/
		
		//Translating created composite service into Lucid
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/parallelcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/lucidtransevaltests/parallelcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean transLogGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(transLogGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a combinational composition plan:
	 * 1. Output accumulator Java class for a composite service with multiple outputs generated
	 * by multiple component services belonging to different layers of the composition plan.
	 * 2. Java class for a component service (W5) with 1 output - to accumulator and another component service.
	 * 3. Java class for a component service (W3) with multiple outputs - to accumulator and multiple component services.
	 * ------------------------------------------------------------------------------------------------------------------
	 * 4. Output accumulator Lucid definition for a composite service with multiple outputs generated
	 * by multiple component services belonging to different layers of the composition plan.
	 * ------------------------------------------------------------------------------------------------------------------
	 * 5. Objective Lucid translation for a combinational organization of component services.
	 * 6. Objective Lucid translation for a composite service with multiple services in first layer.
	 * 7. Objective Lucid translation for a composite service with multiple services in last layer.
	 */
	@Test
	public void combCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/lucidtransevaltests/combcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);
				
		/*
		 * The commented part below was used during the first run of this test case 
		 * to ensure that the composite service used for translation can be created.
		 */
		/*
		//Creating composite service
		FileReqConfigReader configReader = new XMLFileReqConfigReader();
		configReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/combcompsvc/Request_Configuration.xml");
		RequestConfiguration reqConfig = configReader.readReqConfig();
		
		List<String> actualPlanDetails = new ArrayList<String>();
		List<ConstraintAwarePlan> cnstrAwrPlans = ServiceComposition.driveServiceComposition(reqConfig, logger);
		for (ConstraintAwarePlan cnstrAwrPlan : cnstrAwrPlans)
		{
			actualPlanDetails.add(cnstrAwrPlan.toString());
		}
		Collections.sort(actualPlanDetails);
		
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: {} [] W1 {W3}, {} [] W2 {W3}" 
								+ "\nLayer 1: {W1, W2} [] W3 {W4, W5}" 
								+ "\nLayer 2: {W3} [] W4 {W6}, {W3} [] W5 {W7}"
								+ "\nLayer 3: {W4} [] W6 {}, {W5} [] W7 {}");
				
		File actualLogFile = new File(actualLogFileName);
		boolean compLogGenerated = (!(actualLogFile.length() == 0));
		
		assertFalse(compLogGenerated);
		assertEquals(actualPlanDetails, expectedPlanDetails);
		*/
		
		//Translating created composite service into Lucid
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/combcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/lucidtransevaltests/combcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean transLogGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(transLogGenerated);
	}
	
	/**
	 * Tests correct generation of Objective Lucid translation for a composite service with:
	 * 1. Only 1 service layer.
	 * 2. Same user input shared by two component services.
	 */
	@Test
	public void singleLayerCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/lucidtransevaltests/singlelayercompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);		
				
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/singlelayercompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/lucidtransevaltests/singlelayercompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a sequential composition plan with only 1 constraint on each component:
	 * 1. Lucid definition for a component service (W1) with just 1 constraint - on an input from the user.
	 * 2. Lucid definition for a component service (W2) with just 1 constraint - on an input from another component service.
	 * 3. Lucid definition for component service (W1) with a constraint on char type input.
	 */
	@Test
	public void cnstrSeqCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/lucidtransevaltests/cnstrseqcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);		
				
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/cnstrseqcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/lucidtransevaltests/cnstrseqcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a sequential composition plan with multiple constraints on each component:
	 * 1. Lucid definition for a component service (W1) with multiple constraints - on inputs from the user.
	 * 2. Lucid definition for a component service (W2) with multiple constraints - on inputs from another component service.
	 * 3. Lucid definition for a component service (W1) with constraints on all its inputs - from the user.
	 * 4. Lucid definition for a component service (W2) with constraints on all its inputs - from another component service.
	 * 5. Lucid definition for a component service (W1) with multiple constraints on the same input - from the user.
	 * 6. Lucid definition for a component service (W3) with multiple constraints on the same input - from another component service.
	 * 7. Lucid definition for component services (W1, W2) with constraints on int, float, boolean and String type inputs.
	 * 8. Lucid definition for constraints that use >, <, >=, <= and = as operator.
	 * 9. Lucid definition for a component service (W1) with 1 adjusted constraint - on a parameter from the user.
	 * 10. Lucid definition for a component service (W3) with 1 adjusted constraint - on a parameter from another component service.
	 */
	@Test
	public void multiCnstrCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/lucidtransevaltests/multicnstrcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);	
		
		/*
		 * The commented part below was used during the first run of this test case 
		 * to ensure that the composite service used for translation can be created.
		 */
		/*
		//Creating composite service
		FileReqConfigReader configReader = new XMLFileReqConfigReader();
		configReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/multicnstrcompsvc/Request_Configuration.xml");
		RequestConfiguration reqConfig = configReader.readReqConfig();
		
		List<String> actualPlanDetails = new ArrayList<String>();
		List<ConstraintAwarePlan> cnstrAwrPlans = ServiceComposition.driveServiceComposition(reqConfig, logger);
		for (ConstraintAwarePlan cnstrAwrPlan : cnstrAwrPlans)
		{
			actualPlanDetails.add(cnstrAwrPlan.toString());
		}
		Collections.sort(actualPlanDetails);
		
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: {} [float : input11 GREATER_THAN 55.5, float : input11 LESS_THAN 66.6, int : input12 LESS_THAN_OR_EQUAL_TO 50, int : input31 GREATER_THAN_OR_EQUAL_TO 55] W1 {W2, W3}" 
								+ "\nLayer 1: {W1} [boolean : output12 EQUALS true, string : output11 EQUALS abc, string : output11 EQUALS pqr] W2 {W3}" 
								+ "\nLayer 2: {W1, W2} [boolean : output12 EQUALS true, float : output21 GREATER_THAN_OR_EQUAL_TO 101.01, float : output21 LESS_THAN_OR_EQUAL_TO 202.02, string : output11 EQUALS abc, string : output11 EQUALS pqr] W3 {}");
				
		File actualLogFile = new File(actualLogFileName);
		boolean compLogGenerated = (!(actualLogFile.length() == 0));
		
		assertFalse(compLogGenerated);
		assertEquals(actualPlanDetails, expectedPlanDetails);
		*/
		
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/multicnstrcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/lucidtransevaltests/multicnstrcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
	
	/**
	 * Tests correct generation of the following definitions for a constrained split composition plan:
	 * 1. Lucid definition for a component service (W1) with multiple adjusted constraints - on parameters of another service from the user.
	 * 2. Lucid definition for a component service (W1) with multiple adjusted constraints - on parameters of multiple services from the user.
	 * 3. Lucid definition for a component service (W2) with multiple adjusted constraints - on parameter of another service from another service.
	 * 4. Lucid definition for a component service (W2) with multiple adjusted constraints - on parameters of multiple services from other services.
	 * 5. Lucid definition for a component service (W1) with constraints some of its inputs - from the user.
	 * 6. Lucid definition for a component service (W1) with multiple constraints - of its own and adjusted on parameters from the user.
	 * 7. Lucid definition for a component service (W3) with multiple constraints - of its own and adjusted on parameters from other services.
	 */
	@Test
	public void cnstrSplitCompSvc()
	{
		String actualLogFileName = "testinput/translationtests/lucidtransevaltests/cnstrsplitcompsvc/log.txt";
		LogUtil logger = new LogUtil();
		logger.setLogFileName(actualLogFileName);	
		
		/*
		 * The commented part below was used during the first run of this test case 
		 * to ensure that the composite service used for translation can be created.
		 */
		/*
		//Creating composite service
		FileReqConfigReader configReader = new XMLFileReqConfigReader();
		configReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/cnstrsplitcompsvc/Request_Configuration.xml");
		RequestConfiguration reqConfig = configReader.readReqConfig();
		
		List<String> actualPlanDetails = new ArrayList<String>();
		List<ConstraintAwarePlan> cnstrAwrPlans = ServiceComposition.driveServiceComposition(reqConfig, logger);
		for (ConstraintAwarePlan cnstrAwrPlan : cnstrAwrPlans)
		{
			actualPlanDetails.add(cnstrAwrPlan.toString());
		}
		Collections.sort(actualPlanDetails);
		
		List<String> expectedPlanDetails = new ArrayList<String>();
		expectedPlanDetails.add("Layer 0: {} [boolean : input11 EQUALS true, char : input22 EQUALS z, float : input31 GREATER_THAN 55.5, float : input31 LESS_THAN 66.6, string : input21 EQUALS abc] W1 {W2, W3, W4}" 
								+ "\nLayer 1: {W1} [char : output13 EQUALS y, int : output12 LESS_THAN_OR_EQUAL_TO 50, int : output14 GREATER_THAN_OR_EQUAL_TO 55, int : output14 LESS_THAN_OR_EQUAL_TO 60] W2 {}, {W1} [char : output13 EQUALS y, int : output12 LESS_THAN_OR_EQUAL_TO 50, int : output14 GREATER_THAN_OR_EQUAL_TO 55, int : output14 LESS_THAN_OR_EQUAL_TO 60] W3 {}, {W1} [char : output13 EQUALS y, int : output12 LESS_THAN_OR_EQUAL_TO 50, int : output14 GREATER_THAN_OR_EQUAL_TO 55, int : output14 LESS_THAN_OR_EQUAL_TO 60] W4 {}");
				
		File actualLogFile = new File(actualLogFileName);
		boolean compLogGenerated = (!(actualLogFile.length() == 0));
		
		assertFalse(compLogGenerated);
		assertEquals(actualPlanDetails, expectedPlanDetails);
		*/
		
		FileCSConfigReader csConfigReader = new XMLFileCSConfigReader();
		csConfigReader.setConfigFileName("testinput/translationtests/lucidtransevaltests/cnstrsplitcompsvc/CS_Configuration.xml");
		CSConfiguration csConfig = csConfigReader.readCSConfig(logger);
		
		CompositeServiceTranslator csTranslator = new LucidCSTranslator();
		String actualLucidFileName = csTranslator.generateFormalLangCode(csConfig, logger);
		String expectedLucidFileName = "testinput/translationtests/lucidtransevaltests/cnstrsplitcompsvc/expectedlucidprogram.ipl";
		
		File actualLogFile = new File(actualLogFileName);
		boolean logGenerated = (!(actualLogFile.length() == 0));
		
		String expectedProgram = ReadWriteUtil.readTextFile(expectedLucidFileName);
		String actualProgram = ReadWriteUtil.readTextFile(actualLucidFileName);
		assertEquals(expectedProgram, actualProgram);
		assertFalse(logGenerated);
	}
}