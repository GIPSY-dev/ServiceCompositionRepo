package compositionprocesses;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import entities.CompositionPlan;
import entities.CompositionRequest;
import entities.SearchNode;

/**
 * Class for constructing composition plans from the plan sets generated by the Backward Search algorithm.
 * This algorithm also validates the plans, deletes the invalid services and removes invalid and duplicate plans.   
 * @author Jyotsana Gupta
 */
public class PlanConstruction 
{
	public static List<CompositionPlan> constructPlans(CompositionRequest compositionReq, List<Set<SearchNode>> planSets)
	{
		List<CompositionPlan> validPlans = new ArrayList<CompositionPlan>();
		List<Set<SearchNode>> validPlanSets = new ArrayList<Set<SearchNode>>();
		
		for (Set<SearchNode> planSet : planSets)
		{
			int planLayerCount = getPlanLayerCount(planSet);
			CompositionPlan plan = new CompositionPlan(planLayerCount);
			plan.addSearchNodes(planSet);
			
			prunePlan(plan, planLayerCount, compositionReq);
			
			boolean isPlanValid = verifyCompReqOutputs(plan, planLayerCount, compositionReq);
			if (isPlanValid)
			{
				boolean isPlanNew = addNewValidPlanSets(plan, validPlanSets);
				if (isPlanNew)
				{
					validPlans.add(plan);
				}				
			}
		}
		
		return validPlans;
	}
	
	private static int getPlanLayerCount(Set<SearchNode> planSet)
	{
		int maxLayerIndex = -1;
		for (SearchNode searchNode : planSet)
		{
			int currLayerIndex = searchNode.getLayerIndex();
			if (currLayerIndex > maxLayerIndex)
			{
				maxLayerIndex = currLayerIndex;
			}
		}
		
		return (maxLayerIndex + 1);
	}
	
	private static void prunePlan(CompositionPlan plan, int planLayerCount, CompositionRequest compositionReq)
	{
		int removedSvcCount = 0;
		do
		{
			int invalidInputSvcCount = verifyServiceInputs(plan, planLayerCount, compositionReq);
			int invalidOutputSvcCount = verifyServiceOutputs(plan, planLayerCount, compositionReq);
			removedSvcCount = invalidInputSvcCount + invalidOutputSvcCount;			
		} while (removedSvcCount > 0);
	}
	
	private static boolean verifyCompReqOutputs(CompositionPlan plan, int planLayerCount, CompositionRequest compositionReq)
	{
		Set<String> compReqOutputSet = new HashSet<String>(compositionReq.getOutputs());
		Set<String> planOutputSet = new HashSet<String>();
		
		for (int i = 0; i < planLayerCount; i++)
		{
			for (SearchNode searchNode : plan.getServiceLayers().get(i))
			{
				planOutputSet.addAll(searchNode.getService().getOutput());
			}
		}
		
		if (planOutputSet.containsAll(compReqOutputSet))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	private static boolean addNewValidPlanSets(CompositionPlan validPlan, List<Set<SearchNode>> validPlanSets)
	{
		Set<SearchNode> validPlanSet = new HashSet<SearchNode>();
		for (List<SearchNode> serviceLayer : validPlan.getServiceLayers())
		{
			validPlanSet.addAll(serviceLayer);
		}
		
		if (validPlanSets.contains(validPlanSet))
		{
			return false;
		}
		else
		{
			validPlanSets.add(validPlanSet);
			return true;
		}
	}
	
	private static int verifyServiceInputs(CompositionPlan plan, int planLayerCount, CompositionRequest compositionReq)
	{
		Set<String> compReqInputSet = new HashSet<String>(compositionReq.getInputs());
		List<SearchNode> nodesToBeRemoved = new ArrayList<SearchNode>();
		
		for (int i = 0; i < planLayerCount; i++)
		{
			for (SearchNode searchNode : plan.getServiceLayers().get(i))
			{
				Set<String> serviceInputSet = new HashSet<String>(searchNode.getService().getInput());
				Set<String> predOutputSet = new HashSet<String>();
				for (SearchNode predecessor : searchNode.getPredecessors())
				{
					int predLayerIndex = predecessor.getLayerIndex();
					if ((plan.getServiceLayers().get(predLayerIndex).contains(predecessor))
						&& (!nodesToBeRemoved.contains(predecessor)))
					{
						predOutputSet.addAll(predecessor.getService().getOutput());
					}
				}				
				Set<String> availableInputSet = new HashSet<String>(compReqInputSet);
				availableInputSet.addAll(predOutputSet);
				
				if (!availableInputSet.containsAll(serviceInputSet))
				{
					nodesToBeRemoved.add(searchNode);
				}
			}
		}
		
		removeNodes(plan, nodesToBeRemoved);
		
		return nodesToBeRemoved.size();
	}
	
	private static int verifyServiceOutputs(CompositionPlan plan, int planLayerCount, CompositionRequest compositionReq)
	{
		Set<String> compReqOutputSet = new HashSet<String>(compositionReq.getOutputs());
		List<SearchNode> nodesToBeRemoved = new ArrayList<SearchNode>();
		
		for (int i = planLayerCount - 1; i >= 0; i--)
		{
			for (SearchNode searchNode : plan.getServiceLayers().get(i))
			{
				boolean svcHasSuccessors = false;
				for (SearchNode successor : searchNode.getSuccessors())
				{
					int succLayerIndex = successor.getLayerIndex();
					if ((plan.getServiceLayers().get(succLayerIndex).contains(successor))
						&& (!nodesToBeRemoved.contains(successor)))
					{
						svcHasSuccessors = true;
						break;
					}
				}
				
				if (!svcHasSuccessors)
				{
					Set<String> serviceOutputSet = new HashSet<String>(searchNode.getService().getOutput());
					Set<String> reqOutputGenerated = new HashSet<String>(compReqOutputSet);
					reqOutputGenerated.retainAll(serviceOutputSet);
					
					if (reqOutputGenerated.isEmpty())
					{
						nodesToBeRemoved.add(searchNode);
					}
				}
			}
		}
		
		removeNodes(plan, nodesToBeRemoved);
		
		return nodesToBeRemoved.size();
	}
	
	private static void removeNodes(CompositionPlan plan, List<SearchNode> nodesToBeRemoved)
	{
		for (SearchNode searchNode : nodesToBeRemoved)
		{
			int nodeLayerIndex = searchNode.getLayerIndex();
			plan.getServiceLayers().get(nodeLayerIndex).remove(searchNode);
		}
	}
}