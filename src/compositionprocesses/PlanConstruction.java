package compositionprocesses;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import entities.CompositionPlan;
import entities.CompositionRequest;
import entities.SearchNode;

/**
 * Class for constructing composition plans from the plan sets generated by the Backward Search algorithm.
 * This algorithm also validates the plans, deletes the invalid services and removes invalid and duplicate plans.   
 * @author Jyotsana Gupta
 */
public class PlanConstruction 
{
	/**
	 * Method for constructing composition plans from the plan sets generated by the backward search algorithm.
	 * Construction also includes validation and pruning stages.
	 * @param 	compositionReq	Service composition request from the user
	 * @param 	planSets		Sets of search nodes that would constitute composition plans
	 * @return	List of validated and pruned composition plans
	 */
	public static List<CompositionPlan> constructPlans(CompositionRequest compositionReq, List<Set<SearchNode>> planSets)
	{
		List<CompositionPlan> validPlans = new ArrayList<CompositionPlan>();
		List<Set<SearchNode>> validPlanSets = new ArrayList<Set<SearchNode>>();
		
		for (Set<SearchNode> planSet : planSets)
		{
			//Constructing plans populated with all the search nodes from their respective plan sets
			int planLayerCount = getPlanLayerCount(planSet);
			CompositionPlan plan = new CompositionPlan(planLayerCount);
			plan.addSearchNodes(planSet);
			
			//Validating plan search nodes and removing the invalid nodes
			prunePlan(plan, planLayerCount, compositionReq);
			
			//Checking if the pruned plans still produce all the requested outputs
			boolean isPlanValid = verifyCompReqOutputs(plan, planLayerCount, compositionReq);
			if (isPlanValid)
			{
				//Checking if the validated plans already exist in the list of plans to be returned
				boolean isPlanNew = addNewValidPlanSets(plan, validPlanSets);
				if (isPlanNew)
				{
					//Adding new (non-duplicate) plans to the list of plans to be returned
					//Discarding the duplicate plans
					validPlans.add(plan);
				}				
			}
		}
		
		return validPlans;
	}
	
	/**
	 * Method for calculating the number of service layers a plan should have based on the search nodes that it would contain.
	 * @param 	planSet 	Set of search nodes that the plan would contain
	 * @return	Number of service layers that the plan should have
	 */
	private static int getPlanLayerCount(Set<SearchNode> planSet)
	{
		//Number of service layers = (the maximum layer index assigned to a search node in the plan set + 1)
		int maxLayerIndex = -1;
		for (SearchNode searchNode : planSet)
		{
			int currLayerIndex = searchNode.getLayerIndex();
			if (currLayerIndex > maxLayerIndex)
			{
				maxLayerIndex = currLayerIndex;
			}
		}
		
		return (maxLayerIndex + 1);
	}
	
	/**
	 * Method for invoking input and output validations on plan search nodes and removing the invalid nodes.
	 * @param 	plan			Composition plan that needs to be validated
	 * @param 	planLayerCount	Number of service layers in the composition plan
	 * @param 	compositionReq	Service composition request from the user
	 */
	private static void prunePlan(CompositionPlan plan, int planLayerCount, CompositionRequest compositionReq)
	{
		//The validation and pruning is repeated until no more search nodes can be removed
		int removedSvcCount = 0;
		do
		{
			int invalidInputSvcCount = verifyServiceInputs(plan, planLayerCount, compositionReq);
			int invalidOutputSvcCount = verifyServiceOutputs(plan, planLayerCount, compositionReq);
			removedSvcCount = invalidInputSvcCount + invalidOutputSvcCount;			
		} while (removedSvcCount > 0);
	}
	
	/**
	 * Method for checking if a pruned plan still produces all the outputs requested by the user.
	 * @param 	plan			Composition plan that needs to be validated
	 * @param 	planLayerCount	Number of service layers in the composition plan
	 * @param 	compositionReq	Service composition request from the user
	 * @return	true, if the plan produces all the requested ouputs
	 * 			false, otherwise
	 */
	private static boolean verifyCompReqOutputs(CompositionPlan plan, int planLayerCount, CompositionRequest compositionReq)
	{
		Set<String> compReqOutputSet = new HashSet<String>(compositionReq.getOutputs());
		Set<String> planOutputSet = new HashSet<String>();
		
		//Creating a set of all the outputs generated by all the search nodes in the plan
		for (int i = 0; i < planLayerCount; i++)
		{
			for (SearchNode searchNode : plan.getServiceLayers().get(i))
			{
				planOutputSet.addAll(searchNode.getService().getOutput());
			}
		}
		
		//Checking if the search node outputs contain all the requested outputs
		if (planOutputSet.containsAll(compReqOutputSet))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	/**
	 * Method for adding a pruned and validated plan to the list of plans.
	 * A plan is added to the list only if a duplicate plan is not already in the list. 
	 * @param 	validPlan		Plan to be added
	 * @param 	validPlanSets	List of service sets for the plans that are already in the list of plans
	 * @return	true, if the intended plan is successfully added to the list of plans
	 * 			false, if the plan is a duplicate and could not be added to the list
	 */
	private static boolean addNewValidPlanSets(CompositionPlan validPlan, List<Set<SearchNode>> validPlanSets)
	{
		//Creating a set of search nodes that constitute the plan to be added
		Set<SearchNode> validPlanSet = new HashSet<SearchNode>();
		for (List<SearchNode> serviceLayer : validPlan.getServiceLayers())
		{
			validPlanSet.addAll(serviceLayer);
		}
		
		//Checking if this set of search nodes already exists in the list of plans
		if (validPlanSets.contains(validPlanSet))
		{
			//Not adding if the plan set already exists
			return false;
		}
		else
		{
			//Adding the plan set in the list of plan sets if it is a new plan
			validPlanSets.add(validPlanSet);
			return true;
		}
	}
	
	/**
	 * Method for validating that every search node has all its inputs supplied either by the composition request or its predecessors.
	 * Search nodes that fail the validation are removed from the composition plan.
	 * @param 	plan			Composition plan that needs to be validated
	 * @param 	planLayerCount	Number of service layers in the composition plan
	 * @param 	compositionReq	Service composition request from the user
	 * @return	Number of search nodes that fail validation and are removed
	 * 			0, if no search nodes are removed
	 */
	private static int verifyServiceInputs(CompositionPlan plan, int planLayerCount, CompositionRequest compositionReq)
	{
		Set<String> compReqInputSet = new HashSet<String>(compositionReq.getInputs());
		List<SearchNode> nodesToBeRemoved = new ArrayList<SearchNode>();
		
		//Traversing the composition plan from the first to the last service layer
		for (int i = 0; i < planLayerCount; i++)
		{
			//Validating each search node in each service layer
			for (SearchNode searchNode : plan.getServiceLayers().get(i))
			{
				//Taking a union of the composition request's input set and the set of outputs produced by the 
				//current node's predecessors that exist in the current plan and are not marked to be removed (i.e. are valid)
				Set<String> serviceInputSet = new HashSet<String>(searchNode.getService().getInput());
				Set<String> predOutputSet = new HashSet<String>();
				for (SearchNode predecessor : searchNode.getPredecessors())
				{
					int predLayerIndex = predecessor.getLayerIndex();
					if ((plan.getServiceLayers().get(predLayerIndex).contains(predecessor))
						&& (!nodesToBeRemoved.contains(predecessor)))
					{
						predOutputSet.addAll(predecessor.getService().getOutput());
					}
				}				
				Set<String> availableInputSet = new HashSet<String>(compReqInputSet);
				availableInputSet.addAll(predOutputSet);
				
				//In case the available inputs do not provide all the inputs required by the current node
				if (!availableInputSet.containsAll(serviceInputSet))
				{
					//Mark the current node as invalid
					nodesToBeRemoved.add(searchNode);
				}
			}
		}
		
		//Remove the invalid nodes from the plan
		removeNodes(plan, nodesToBeRemoved);
		
		return nodesToBeRemoved.size();
	}
	
	/**
	 * Method for validating that every search node with no successors produces at least 1 requested output.
	 * Search nodes that fail the validation are removed from the composition plan.
	 * @param 	plan			Composition plan that needs to be validated
	 * @param 	planLayerCount	Number of service layers in the composition plan
	 * @param 	compositionReq	Service composition request from the user
	 * @return	Number of search nodes that fail validation and are removed
	 * 			0, if no search nodes are removed
	 */
	private static int verifyServiceOutputs(CompositionPlan plan, int planLayerCount, CompositionRequest compositionReq)
	{
		Set<String> compReqOutputSet = new HashSet<String>(compositionReq.getOutputs());
		List<SearchNode> nodesToBeRemoved = new ArrayList<SearchNode>();
		
		//Traversing the composition plan from the last to the first service layer
		for (int i = planLayerCount - 1; i >= 0; i--)
		{
			//Validating each search node in each service layer
			for (SearchNode searchNode : plan.getServiceLayers().get(i))
			{
				//Checking if the current node has any successors and if those successors exist 
				//in the current plan and if they are not marked to be removed (i.e. if they are valid)
				boolean svcHasSuccessors = false;
				for (SearchNode successor : searchNode.getSuccessors())
				{
					int succLayerIndex = successor.getLayerIndex();
					if ((plan.getServiceLayers().get(succLayerIndex).contains(successor))
						&& (!nodesToBeRemoved.contains(successor)))
					{
						svcHasSuccessors = true;
						break;
					}
				}
				
				//In case the current node does not have any valid successors in the current plan
				if (!svcHasSuccessors)
				{
					Set<String> serviceOutputSet = new HashSet<String>(searchNode.getService().getOutput());
					Set<String> reqOutputGenerated = new HashSet<String>(compReqOutputSet);
					reqOutputGenerated.retainAll(serviceOutputSet);
				
					//If the intersection of the search node output set and the composition request 
					//output set is null, mark the current node as invalid
					if (reqOutputGenerated.isEmpty())
					{
						nodesToBeRemoved.add(searchNode);
					}
				}
			}
		}
		
		//Remove the invalid nodes from the plan
		removeNodes(plan, nodesToBeRemoved);
		
		return nodesToBeRemoved.size();
	}
	
	/**
	 * Method for removing search nodes from a composition plan.
	 * @param 	plan				Composition plan from which nodes need to be removed
	 * @param 	nodesToBeRemoved	List of nodes to be removed
	 */
	private static void removeNodes(CompositionPlan plan, List<SearchNode> nodesToBeRemoved)
	{
		for (SearchNode searchNode : nodesToBeRemoved)
		{
			//Removing the search node from its service layer
			int nodeLayerIndex = searchNode.getLayerIndex();
			plan.getServiceLayers().get(nodeLayerIndex).remove(searchNode);
		}
	}
}